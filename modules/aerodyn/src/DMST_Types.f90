!STARTOFREGISTRYGENERATEDFILE 'DMST_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! DMST_Types
!.................................................................................................................................
! This file is part of DMST.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in DMST. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE DMST_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE UnsteadyAero_Types
USE NWTC_Library
IMPLICIT NONE
! =========  DMST_InitInputType  =======
  TYPE, PUBLIC :: DMST_InitInputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      !< Chord length at node [m]
    INTEGER(IntKi)  :: numBlades = 0_IntKi      !< Number of blades [-]
    REAL(ReKi)  :: airDens = 0.0_ReKi      !< Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc = 0.0_ReKi      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: numBladeNodes = 0_IntKi      !< Number of blade nodes used in the analysis [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    INTEGER(IntKi)  :: DMSTMod = 0_IntKi      !< Type of momentum theory model (switch) {1=classic, 2=high load} [-]
    INTEGER(IntKi)  :: Nst = 0_IntKi      !< Number of streamtubes [-]
    REAL(ReKi)  :: DMSTRes = 0.0_ReKi      !< Resolution of induction factor initial guess array [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: radius      !< Rotor radius [m]
    LOGICAL  :: UA_Flag = .false.      !< Logical flag indicating whether to use UnsteadyAero [-]
    TYPE(UA_InitInputType)  :: UA_Init      !< InitInput data for UA model [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rLocal      !< Radial distance to blade node from the center of rotation, measured in the rotor plane, needed for UA [m]
  END TYPE DMST_InitInputType
! =======================
! =========  DMST_InitOutputType  =======
  TYPE, PUBLIC :: DMST_InitOutputType
    TYPE(ProgDesc)  :: Version      !<  [-]
  END TYPE DMST_InitOutputType
! =======================
! =========  DMST_ContinuousStateType  =======
  TYPE, PUBLIC :: DMST_ContinuousStateType
    TYPE(UA_ContinuousStateType)  :: UA      !< UA module continuous states [-]
  END TYPE DMST_ContinuousStateType
! =======================
! =========  DMST_DiscreteStateType  =======
  TYPE, PUBLIC :: DMST_DiscreteStateType
    TYPE(UA_DiscreteStateType)  :: UA      !< UA module discrete states [-]
  END TYPE DMST_DiscreteStateType
! =======================
! =========  DMST_OtherStateType  =======
  TYPE, PUBLIC :: DMST_OtherStateType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vstr      !< Stored blade structural velocity, airfoil coordinates [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: M_ag      !< Stored blade orientation matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: blade_theta      !< Stored blade azimuth [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: indf      !< Stored induction factor [-]
    TYPE(UA_OtherStateType)  :: UA      !< Other states for UnsteadyAero [-]
  END TYPE DMST_OtherStateType
! =======================
! =========  DMST_MiscVarType  =======
  TYPE, PUBLIC :: DMST_MiscVarType
    TYPE(UA_MiscVarType)  :: UA      !< Misc vars for UnsteadyAero [-]
    TYPE(UA_OutputType)  :: y_UA      !< Outputs from UnsteadyAero [-]
    TYPE(UA_InputType) , DIMENSION(:,:,:), ALLOCATABLE  :: u_UA      !< Inputs to UnsteadyAero at t and t+dt [-]
  END TYPE DMST_MiscVarType
! =======================
! =========  DMST_ParameterType  =======
  TYPE, PUBLIC :: DMST_ParameterType
    REAL(DbKi)  :: DT = 0.0_R8Ki      !< Time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      !< Chord length at node [m]
    INTEGER(IntKi)  :: numBlades = 0_IntKi      !< Number of blades [-]
    REAL(ReKi)  :: airDens = 0.0_ReKi      !< Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc = 0.0_ReKi      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: numBladeNodes = 0_IntKi      !< Number of blade nodes used in the analysis [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    INTEGER(IntKi)  :: DMSTMod = 0_IntKi      !< Type of momentum theory model (switch) {1=classic, 2=high load} [-]
    INTEGER(IntKi)  :: Nst = 0_IntKi      !< Number of streamtubes [-]
    REAL(ReKi)  :: DMSTRes = 0.0_ReKi      !< Resolution of induction factor initial guess array [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: radius      !< Rotor radius [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dTheta      !< Total streamtube angle [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: theta_st      !< Azimuthal position of streamtube midpoint [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: indf      !< Induction factor initial guess array [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CTmo      !< Thrust coefficient from linear momentum theory [-]
    LOGICAL  :: UA_Flag = .false.      !< Logical flag indicating whether to use UnsteadyAero [-]
    TYPE(UA_ParameterType)  :: UA      !< Parameters for UnsteadyAero [-]
  END TYPE DMST_ParameterType
! =======================
! =========  DMST_InputType  =======
  TYPE, PUBLIC :: DMST_InputType
    REAL(ReKi)  :: omega = 0.0_ReKi      !< Rotor angular velocity [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: omega_z      !< Blade pitch velocity [rad/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vinf      !< Free-stream velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: blade_theta      !< Streamtube angle of each blade node in upstream and downstream sweeps [rad]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vstr      !< Blade structural velocity, airfoil coordinates [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vstr_g      !< Blade structural velocity, global coordinates [m/s]
    REAL(R8Ki) , DIMENSION(:,:,:,:), ALLOCATABLE  :: M_ag      !< Orientation matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PitchAndTwist      !< Local pitch + twist angle [rad]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: blade_st      !< Streamtube corresponding to each blade node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: UserProp      !< Optional user property for interpolating airfoils (per element per blade) [-]
  END TYPE DMST_InputType
! =======================
! =========  DMST_OutputType  =======
  TYPE, PUBLIC :: DMST_OutputType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vind      !< Global induced velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: indf      !< Induction factor at each blade node [-]
  END TYPE DMST_OutputType
! =======================
CONTAINS

subroutine DMST_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_InitInputType), intent(in) :: SrcInitInputData
   type(DMST_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInitInputData%chord)) then
      LB(1:2) = lbound(SrcInitInputData%chord, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%chord, kind=B8Ki)
      if (.not. allocated(DstInitInputData%chord)) then
         allocate(DstInitInputData%chord(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%chord.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%chord = SrcInitInputData%chord
   end if
   DstInitInputData%numBlades = SrcInitInputData%numBlades
   DstInitInputData%airDens = SrcInitInputData%airDens
   DstInitInputData%kinVisc = SrcInitInputData%kinVisc
   DstInitInputData%numBladeNodes = SrcInitInputData%numBladeNodes
   if (allocated(SrcInitInputData%AFindx)) then
      LB(1:2) = lbound(SrcInitInputData%AFindx, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%AFindx, kind=B8Ki)
      if (.not. allocated(DstInitInputData%AFindx)) then
         allocate(DstInitInputData%AFindx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AFindx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%AFindx = SrcInitInputData%AFindx
   end if
   DstInitInputData%DMSTMod = SrcInitInputData%DMSTMod
   DstInitInputData%Nst = SrcInitInputData%Nst
   DstInitInputData%DMSTRes = SrcInitInputData%DMSTRes
   if (allocated(SrcInitInputData%radius)) then
      LB(1:2) = lbound(SrcInitInputData%radius, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%radius, kind=B8Ki)
      if (.not. allocated(DstInitInputData%radius)) then
         allocate(DstInitInputData%radius(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%radius.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%radius = SrcInitInputData%radius
   end if
   DstInitInputData%UA_Flag = SrcInitInputData%UA_Flag
   call UA_CopyInitInput(SrcInitInputData%UA_Init, DstInitInputData%UA_Init, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstInitInputData%RootName = SrcInitInputData%RootName
   if (allocated(SrcInitInputData%rLocal)) then
      LB(1:2) = lbound(SrcInitInputData%rLocal, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%rLocal, kind=B8Ki)
      if (.not. allocated(DstInitInputData%rLocal)) then
         allocate(DstInitInputData%rLocal(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%rLocal.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%rLocal = SrcInitInputData%rLocal
   end if
end subroutine

subroutine DMST_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(DMST_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitInputData%chord)) then
      deallocate(InitInputData%chord)
   end if
   if (allocated(InitInputData%AFindx)) then
      deallocate(InitInputData%AFindx)
   end if
   if (allocated(InitInputData%radius)) then
      deallocate(InitInputData%radius)
   end if
   call UA_DestroyInitInput(InitInputData%UA_Init, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(InitInputData%rLocal)) then
      deallocate(InitInputData%rLocal)
   end if
end subroutine

subroutine DMST_PackInitInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackInitInput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%chord)
   call RegPack(RF, InData%numBlades)
   call RegPack(RF, InData%airDens)
   call RegPack(RF, InData%kinVisc)
   call RegPack(RF, InData%numBladeNodes)
   call RegPackAlloc(RF, InData%AFindx)
   call RegPack(RF, InData%DMSTMod)
   call RegPack(RF, InData%Nst)
   call RegPack(RF, InData%DMSTRes)
   call RegPackAlloc(RF, InData%radius)
   call RegPack(RF, InData%UA_Flag)
   call UA_PackInitInput(RF, InData%UA_Init) 
   call RegPack(RF, InData%RootName)
   call RegPackAlloc(RF, InData%rLocal)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackInitInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackInitInput'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%chord); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numBlades); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%airDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%kinVisc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numBladeNodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AFindx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DMSTMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DMSTRes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%radius); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UA_Flag); if (RegCheckErr(RF, RoutineName)) return
   call UA_UnpackInitInput(RF, OutData%UA_Init) ! UA_Init 
   call RegUnpack(RF, OutData%RootName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%rLocal); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_InitOutputType), intent(in) :: SrcInitOutputData
   type(DMST_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyProgDesc(SrcInitOutputData%Version, DstInitOutputData%Version, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DMST_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(DMST_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyProgDesc(InitOutputData%Version, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DMST_PackInitOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackInitOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackProgDesc(RF, InData%Version) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackInitOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackInitOutput'
   if (RF%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackProgDesc(RF, OutData%Version) ! Version 
end subroutine

subroutine DMST_CopyContState(SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_ContinuousStateType), intent(in) :: SrcContStateData
   type(DMST_ContinuousStateType), intent(inout) :: DstContStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_CopyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_CopyContState(SrcContStateData%UA, DstContStateData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DMST_DestroyContState(ContStateData, ErrStat, ErrMsg)
   type(DMST_ContinuousStateType), intent(inout) :: ContStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_DestroyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_DestroyContState(ContStateData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DMST_PackContState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackContState'
   if (RF%ErrStat >= AbortErrLev) return
   call UA_PackContState(RF, InData%UA) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackContState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackContState'
   if (RF%ErrStat /= ErrID_None) return
   call UA_UnpackContState(RF, OutData%UA) ! UA 
end subroutine

subroutine DMST_CopyDiscState(SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_DiscreteStateType), intent(in) :: SrcDiscStateData
   type(DMST_DiscreteStateType), intent(inout) :: DstDiscStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_CopyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_CopyDiscState(SrcDiscStateData%UA, DstDiscStateData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DMST_DestroyDiscState(DiscStateData, ErrStat, ErrMsg)
   type(DMST_DiscreteStateType), intent(inout) :: DiscStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_DestroyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_DestroyDiscState(DiscStateData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DMST_PackDiscState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackDiscState'
   if (RF%ErrStat >= AbortErrLev) return
   call UA_PackDiscState(RF, InData%UA) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackDiscState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackDiscState'
   if (RF%ErrStat /= ErrID_None) return
   call UA_UnpackDiscState(RF, OutData%UA) ! UA 
end subroutine

subroutine DMST_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_OtherStateType), intent(in) :: SrcOtherStateData
   type(DMST_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOtherStateData%Vstr)) then
      LB(1:3) = lbound(SrcOtherStateData%Vstr, kind=B8Ki)
      UB(1:3) = ubound(SrcOtherStateData%Vstr, kind=B8Ki)
      if (.not. allocated(DstOtherStateData%Vstr)) then
         allocate(DstOtherStateData%Vstr(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Vstr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%Vstr = SrcOtherStateData%Vstr
   end if
   if (allocated(SrcOtherStateData%M_ag)) then
      LB(1:4) = lbound(SrcOtherStateData%M_ag, kind=B8Ki)
      UB(1:4) = ubound(SrcOtherStateData%M_ag, kind=B8Ki)
      if (.not. allocated(DstOtherStateData%M_ag)) then
         allocate(DstOtherStateData%M_ag(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%M_ag.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%M_ag = SrcOtherStateData%M_ag
   end if
   if (allocated(SrcOtherStateData%blade_theta)) then
      LB(1:2) = lbound(SrcOtherStateData%blade_theta, kind=B8Ki)
      UB(1:2) = ubound(SrcOtherStateData%blade_theta, kind=B8Ki)
      if (.not. allocated(DstOtherStateData%blade_theta)) then
         allocate(DstOtherStateData%blade_theta(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%blade_theta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%blade_theta = SrcOtherStateData%blade_theta
   end if
   if (allocated(SrcOtherStateData%indf)) then
      LB(1:2) = lbound(SrcOtherStateData%indf, kind=B8Ki)
      UB(1:2) = ubound(SrcOtherStateData%indf, kind=B8Ki)
      if (.not. allocated(DstOtherStateData%indf)) then
         allocate(DstOtherStateData%indf(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%indf.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%indf = SrcOtherStateData%indf
   end if
   call UA_CopyOtherState(SrcOtherStateData%UA, DstOtherStateData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DMST_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(DMST_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OtherStateData%Vstr)) then
      deallocate(OtherStateData%Vstr)
   end if
   if (allocated(OtherStateData%M_ag)) then
      deallocate(OtherStateData%M_ag)
   end if
   if (allocated(OtherStateData%blade_theta)) then
      deallocate(OtherStateData%blade_theta)
   end if
   if (allocated(OtherStateData%indf)) then
      deallocate(OtherStateData%indf)
   end if
   call UA_DestroyOtherState(OtherStateData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DMST_PackOtherState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackOtherState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%Vstr)
   call RegPackAlloc(RF, InData%M_ag)
   call RegPackAlloc(RF, InData%blade_theta)
   call RegPackAlloc(RF, InData%indf)
   call UA_PackOtherState(RF, InData%UA) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackOtherState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackOtherState'
   integer(B8Ki)   :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%Vstr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%M_ag); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%blade_theta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%indf); if (RegCheckErr(RF, RoutineName)) return
   call UA_UnpackOtherState(RF, OutData%UA) ! UA 
end subroutine

subroutine DMST_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_MiscVarType), intent(in) :: SrcMiscData
   type(DMST_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_CopyMisc(SrcMiscData%UA, DstMiscData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call UA_CopyOutput(SrcMiscData%y_UA, DstMiscData%y_UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMiscData%u_UA)) then
      LB(1:3) = lbound(SrcMiscData%u_UA, kind=B8Ki)
      UB(1:3) = ubound(SrcMiscData%u_UA, kind=B8Ki)
      if (.not. allocated(DstMiscData%u_UA)) then
         allocate(DstMiscData%u_UA(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_UA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i3 = LB(3), UB(3)
         do i2 = LB(2), UB(2)
            do i1 = LB(1), UB(1)
               call UA_CopyInput(SrcMiscData%u_UA(i1,i2,i3), DstMiscData%u_UA(i1,i2,i3), CtrlCode, ErrStat2, ErrMsg2)
               call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
               if (ErrStat >= AbortErrLev) return
            end do
         end do
      end do
   end if
end subroutine

subroutine DMST_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(DMST_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_DestroyMisc(MiscData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call UA_DestroyOutput(MiscData%y_UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%u_UA)) then
      LB(1:3) = lbound(MiscData%u_UA, kind=B8Ki)
      UB(1:3) = ubound(MiscData%u_UA, kind=B8Ki)
      do i3 = LB(3), UB(3)
         do i2 = LB(2), UB(2)
            do i1 = LB(1), UB(1)
               call UA_DestroyInput(MiscData%u_UA(i1,i2,i3), ErrStat2, ErrMsg2)
               call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            end do
         end do
      end do
      deallocate(MiscData%u_UA)
   end if
end subroutine

subroutine DMST_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackMisc'
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   if (RF%ErrStat >= AbortErrLev) return
   call UA_PackMisc(RF, InData%UA) 
   call UA_PackOutput(RF, InData%y_UA) 
   call RegPack(RF, allocated(InData%u_UA))
   if (allocated(InData%u_UA)) then
      call RegPackBounds(RF, 3, lbound(InData%u_UA, kind=B8Ki), ubound(InData%u_UA, kind=B8Ki))
      LB(1:3) = lbound(InData%u_UA, kind=B8Ki)
      UB(1:3) = ubound(InData%u_UA, kind=B8Ki)
      do i3 = LB(3), UB(3)
         do i2 = LB(2), UB(2)
            do i1 = LB(1), UB(1)
               call UA_PackInput(RF, InData%u_UA(i1,i2,i3)) 
            end do
         end do
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackMisc'
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call UA_UnpackMisc(RF, OutData%UA) ! UA 
   call UA_UnpackOutput(RF, OutData%y_UA) ! y_UA 
   if (allocated(OutData%u_UA)) deallocate(OutData%u_UA)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 3, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%u_UA(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_UA.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i3 = LB(3), UB(3)
         do i2 = LB(2), UB(2)
            do i1 = LB(1), UB(1)
               call UA_UnpackInput(RF, OutData%u_UA(i1,i2,i3)) ! u_UA 
            end do
         end do
      end do
   end if
end subroutine

subroutine DMST_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_ParameterType), intent(in) :: SrcParamData
   type(DMST_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%DT = SrcParamData%DT
   if (allocated(SrcParamData%chord)) then
      LB(1:2) = lbound(SrcParamData%chord, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%chord, kind=B8Ki)
      if (.not. allocated(DstParamData%chord)) then
         allocate(DstParamData%chord(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%chord.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%chord = SrcParamData%chord
   end if
   DstParamData%numBlades = SrcParamData%numBlades
   DstParamData%airDens = SrcParamData%airDens
   DstParamData%kinVisc = SrcParamData%kinVisc
   DstParamData%numBladeNodes = SrcParamData%numBladeNodes
   if (allocated(SrcParamData%AFindx)) then
      LB(1:2) = lbound(SrcParamData%AFindx, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%AFindx, kind=B8Ki)
      if (.not. allocated(DstParamData%AFindx)) then
         allocate(DstParamData%AFindx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFindx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%AFindx = SrcParamData%AFindx
   end if
   DstParamData%DMSTMod = SrcParamData%DMSTMod
   DstParamData%Nst = SrcParamData%Nst
   DstParamData%DMSTRes = SrcParamData%DMSTRes
   if (allocated(SrcParamData%radius)) then
      LB(1:2) = lbound(SrcParamData%radius, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%radius, kind=B8Ki)
      if (.not. allocated(DstParamData%radius)) then
         allocate(DstParamData%radius(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%radius.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%radius = SrcParamData%radius
   end if
   if (allocated(SrcParamData%dTheta)) then
      LB(1:1) = lbound(SrcParamData%dTheta, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%dTheta, kind=B8Ki)
      if (.not. allocated(DstParamData%dTheta)) then
         allocate(DstParamData%dTheta(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dTheta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%dTheta = SrcParamData%dTheta
   end if
   if (allocated(SrcParamData%theta_st)) then
      LB(1:1) = lbound(SrcParamData%theta_st, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%theta_st, kind=B8Ki)
      if (.not. allocated(DstParamData%theta_st)) then
         allocate(DstParamData%theta_st(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%theta_st.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%theta_st = SrcParamData%theta_st
   end if
   if (allocated(SrcParamData%indf)) then
      LB(1:1) = lbound(SrcParamData%indf, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%indf, kind=B8Ki)
      if (.not. allocated(DstParamData%indf)) then
         allocate(DstParamData%indf(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%indf.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%indf = SrcParamData%indf
   end if
   if (allocated(SrcParamData%CTmo)) then
      LB(1:1) = lbound(SrcParamData%CTmo, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%CTmo, kind=B8Ki)
      if (.not. allocated(DstParamData%CTmo)) then
         allocate(DstParamData%CTmo(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%CTmo.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%CTmo = SrcParamData%CTmo
   end if
   DstParamData%UA_Flag = SrcParamData%UA_Flag
   call UA_CopyParam(SrcParamData%UA, DstParamData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DMST_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(DMST_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%chord)) then
      deallocate(ParamData%chord)
   end if
   if (allocated(ParamData%AFindx)) then
      deallocate(ParamData%AFindx)
   end if
   if (allocated(ParamData%radius)) then
      deallocate(ParamData%radius)
   end if
   if (allocated(ParamData%dTheta)) then
      deallocate(ParamData%dTheta)
   end if
   if (allocated(ParamData%theta_st)) then
      deallocate(ParamData%theta_st)
   end if
   if (allocated(ParamData%indf)) then
      deallocate(ParamData%indf)
   end if
   if (allocated(ParamData%CTmo)) then
      deallocate(ParamData%CTmo)
   end if
   call UA_DestroyParam(ParamData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DMST_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DT)
   call RegPackAlloc(RF, InData%chord)
   call RegPack(RF, InData%numBlades)
   call RegPack(RF, InData%airDens)
   call RegPack(RF, InData%kinVisc)
   call RegPack(RF, InData%numBladeNodes)
   call RegPackAlloc(RF, InData%AFindx)
   call RegPack(RF, InData%DMSTMod)
   call RegPack(RF, InData%Nst)
   call RegPack(RF, InData%DMSTRes)
   call RegPackAlloc(RF, InData%radius)
   call RegPackAlloc(RF, InData%dTheta)
   call RegPackAlloc(RF, InData%theta_st)
   call RegPackAlloc(RF, InData%indf)
   call RegPackAlloc(RF, InData%CTmo)
   call RegPack(RF, InData%UA_Flag)
   call UA_PackParam(RF, InData%UA) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackParam'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%chord); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numBlades); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%airDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%kinVisc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numBladeNodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AFindx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DMSTMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DMSTRes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%radius); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dTheta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%theta_st); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%indf); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CTmo); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UA_Flag); if (RegCheckErr(RF, RoutineName)) return
   call UA_UnpackParam(RF, OutData%UA) ! UA 
end subroutine

subroutine DMST_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_InputType), intent(in) :: SrcInputData
   type(DMST_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DMST_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInputData%omega = SrcInputData%omega
   if (allocated(SrcInputData%omega_z)) then
      LB(1:2) = lbound(SrcInputData%omega_z, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%omega_z, kind=B8Ki)
      if (.not. allocated(DstInputData%omega_z)) then
         allocate(DstInputData%omega_z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%omega_z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%omega_z = SrcInputData%omega_z
   end if
   if (allocated(SrcInputData%Vinf)) then
      LB(1:3) = lbound(SrcInputData%Vinf, kind=B8Ki)
      UB(1:3) = ubound(SrcInputData%Vinf, kind=B8Ki)
      if (.not. allocated(DstInputData%Vinf)) then
         allocate(DstInputData%Vinf(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vinf.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%Vinf = SrcInputData%Vinf
   end if
   if (allocated(SrcInputData%blade_theta)) then
      LB(1:2) = lbound(SrcInputData%blade_theta, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%blade_theta, kind=B8Ki)
      if (.not. allocated(DstInputData%blade_theta)) then
         allocate(DstInputData%blade_theta(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%blade_theta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%blade_theta = SrcInputData%blade_theta
   end if
   if (allocated(SrcInputData%Vstr)) then
      LB(1:3) = lbound(SrcInputData%Vstr, kind=B8Ki)
      UB(1:3) = ubound(SrcInputData%Vstr, kind=B8Ki)
      if (.not. allocated(DstInputData%Vstr)) then
         allocate(DstInputData%Vstr(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vstr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%Vstr = SrcInputData%Vstr
   end if
   if (allocated(SrcInputData%Vstr_g)) then
      LB(1:3) = lbound(SrcInputData%Vstr_g, kind=B8Ki)
      UB(1:3) = ubound(SrcInputData%Vstr_g, kind=B8Ki)
      if (.not. allocated(DstInputData%Vstr_g)) then
         allocate(DstInputData%Vstr_g(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vstr_g.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%Vstr_g = SrcInputData%Vstr_g
   end if
   if (allocated(SrcInputData%M_ag)) then
      LB(1:4) = lbound(SrcInputData%M_ag, kind=B8Ki)
      UB(1:4) = ubound(SrcInputData%M_ag, kind=B8Ki)
      if (.not. allocated(DstInputData%M_ag)) then
         allocate(DstInputData%M_ag(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%M_ag.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%M_ag = SrcInputData%M_ag
   end if
   if (allocated(SrcInputData%PitchAndTwist)) then
      LB(1:2) = lbound(SrcInputData%PitchAndTwist, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%PitchAndTwist, kind=B8Ki)
      if (.not. allocated(DstInputData%PitchAndTwist)) then
         allocate(DstInputData%PitchAndTwist(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%PitchAndTwist.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%PitchAndTwist = SrcInputData%PitchAndTwist
   end if
   if (allocated(SrcInputData%blade_st)) then
      LB(1:2) = lbound(SrcInputData%blade_st, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%blade_st, kind=B8Ki)
      if (.not. allocated(DstInputData%blade_st)) then
         allocate(DstInputData%blade_st(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%blade_st.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%blade_st = SrcInputData%blade_st
   end if
   if (allocated(SrcInputData%UserProp)) then
      LB(1:2) = lbound(SrcInputData%UserProp, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%UserProp, kind=B8Ki)
      if (.not. allocated(DstInputData%UserProp)) then
         allocate(DstInputData%UserProp(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%UserProp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%UserProp = SrcInputData%UserProp
   end if
end subroutine

subroutine DMST_DestroyInput(InputData, ErrStat, ErrMsg)
   type(DMST_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DMST_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InputData%omega_z)) then
      deallocate(InputData%omega_z)
   end if
   if (allocated(InputData%Vinf)) then
      deallocate(InputData%Vinf)
   end if
   if (allocated(InputData%blade_theta)) then
      deallocate(InputData%blade_theta)
   end if
   if (allocated(InputData%Vstr)) then
      deallocate(InputData%Vstr)
   end if
   if (allocated(InputData%Vstr_g)) then
      deallocate(InputData%Vstr_g)
   end if
   if (allocated(InputData%M_ag)) then
      deallocate(InputData%M_ag)
   end if
   if (allocated(InputData%PitchAndTwist)) then
      deallocate(InputData%PitchAndTwist)
   end if
   if (allocated(InputData%blade_st)) then
      deallocate(InputData%blade_st)
   end if
   if (allocated(InputData%UserProp)) then
      deallocate(InputData%UserProp)
   end if
end subroutine

subroutine DMST_PackInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackInput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%omega)
   call RegPackAlloc(RF, InData%omega_z)
   call RegPackAlloc(RF, InData%Vinf)
   call RegPackAlloc(RF, InData%blade_theta)
   call RegPackAlloc(RF, InData%Vstr)
   call RegPackAlloc(RF, InData%Vstr_g)
   call RegPackAlloc(RF, InData%M_ag)
   call RegPackAlloc(RF, InData%PitchAndTwist)
   call RegPackAlloc(RF, InData%blade_st)
   call RegPackAlloc(RF, InData%UserProp)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackInput'
   integer(B8Ki)   :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%omega); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%omega_z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Vinf); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%blade_theta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Vstr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Vstr_g); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%M_ag); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PitchAndTwist); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%blade_st); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%UserProp); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_OutputType), intent(in) :: SrcOutputData
   type(DMST_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DMST_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputData%Vind)) then
      LB(1:3) = lbound(SrcOutputData%Vind, kind=B8Ki)
      UB(1:3) = ubound(SrcOutputData%Vind, kind=B8Ki)
      if (.not. allocated(DstOutputData%Vind)) then
         allocate(DstOutputData%Vind(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vind.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Vind = SrcOutputData%Vind
   end if
   if (allocated(SrcOutputData%indf)) then
      LB(1:2) = lbound(SrcOutputData%indf, kind=B8Ki)
      UB(1:2) = ubound(SrcOutputData%indf, kind=B8Ki)
      if (.not. allocated(DstOutputData%indf)) then
         allocate(DstOutputData%indf(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%indf.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%indf = SrcOutputData%indf
   end if
end subroutine

subroutine DMST_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(DMST_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DMST_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputData%Vind)) then
      deallocate(OutputData%Vind)
   end if
   if (allocated(OutputData%indf)) then
      deallocate(OutputData%indf)
   end if
end subroutine

subroutine DMST_PackOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%Vind)
   call RegPackAlloc(RF, InData%indf)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackOutput'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%Vind); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%indf); if (RegCheckErr(RF, RoutineName)) return
end subroutine
END MODULE DMST_Types
!ENDOFREGISTRYGENERATEDFILE
