!STARTOFREGISTRYGENERATEDFILE 'DMST_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! DMST_Types
!.................................................................................................................................
! This file is part of DMST.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in DMST. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE DMST_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE NWTC_Library
IMPLICIT NONE
! =========  DMST_InitInputType  =======
  TYPE, PUBLIC :: DMST_InitInputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      !< Chord length at node [m]
    INTEGER(IntKi)  :: numBlades = 0_IntKi      !< Number of blades [-]
    REAL(ReKi)  :: airDens = 0.0_ReKi      !< Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc = 0.0_ReKi      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: numBladeNodes = 0_IntKi      !< Number of blade nodes used in the analysis [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    INTEGER(IntKi)  :: DMSTMod = 0_IntKi      !< Type of momentum theory model (switch) {1=classic, 2=high load} [-]
    INTEGER(IntKi)  :: Nst = 0_IntKi      !< Number of streamtubes [-]
    REAL(ReKi)  :: DMSTRes = 0.0_ReKi      !< Resolution of induction factor initial guess array [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: radius      !< Rotor radius [m]
  END TYPE DMST_InitInputType
! =======================
! =========  DMST_InitOutputType  =======
  TYPE, PUBLIC :: DMST_InitOutputType
    TYPE(ProgDesc)  :: Version      !<  [-]
  END TYPE DMST_InitOutputType
! =======================
! =========  DMST_OtherStateType  =======
  TYPE, PUBLIC :: DMST_OtherStateType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vstr      !< Stored blade structural velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: M_ag      !< Stored blade orientation matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: blade_theta      !< Stored blade azimuth [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: indf      !< Stored induction factor [-]
  END TYPE DMST_OtherStateType
! =======================
! =========  DMST_ParameterType  =======
  TYPE, PUBLIC :: DMST_ParameterType
    REAL(DbKi)  :: DT = 0.0_R8Ki      !< Time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      !< Chord length at node [m]
    INTEGER(IntKi)  :: numBlades = 0_IntKi      !< Number of blades [-]
    REAL(ReKi)  :: airDens = 0.0_ReKi      !< Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc = 0.0_ReKi      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: numBladeNodes = 0_IntKi      !< Number of blade nodes used in the analysis [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    INTEGER(IntKi)  :: DMSTMod = 0_IntKi      !< Type of momentum theory model (switch) {1=classic, 2=high load} [-]
    INTEGER(IntKi)  :: Nst = 0_IntKi      !< Number of streamtubes [-]
    REAL(ReKi)  :: DMSTRes = 0.0_ReKi      !< Resolution of induction factor initial guess array [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: radius      !< Rotor radius [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dTheta      !< Total streamtube angle [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: theta_st      !< Azimuthal position of streamtube midpoint [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: indf      !< Induction factor initial guess array [-]
  END TYPE DMST_ParameterType
! =======================
! =========  DMST_InputType  =======
  TYPE, PUBLIC :: DMST_InputType
    REAL(ReKi)  :: omega = 0.0_ReKi      !< Rotor angular velocity [rad/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vinf      !< Free-stream velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: blade_theta      !< Streamtube angle of each blade node in upstream and downstream sweeps [rad]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vstr      !< Structural velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: M_ag      !< Orientation matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PitchAndTwist      !< Local pitch + twist angle [rad]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: blade_st      !< Streamtube corresponding to each blade node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: UserProp      !< Optional user property for interpolating airfoils (per element per blade) [-]
  END TYPE DMST_InputType
! =======================
! =========  DMST_OutputType  =======
  TYPE, PUBLIC :: DMST_OutputType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vind      !< Global induced velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: indf      !< Induction factor at each blade node [-]
  END TYPE DMST_OutputType
! =======================
CONTAINS

subroutine DMST_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_InitInputType), intent(in) :: SrcInitInputData
   type(DMST_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DMST_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInitInputData%chord)) then
      LB(1:2) = lbound(SrcInitInputData%chord, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%chord, kind=B8Ki)
      if (.not. allocated(DstInitInputData%chord)) then
         allocate(DstInitInputData%chord(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%chord.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%chord = SrcInitInputData%chord
   end if
   DstInitInputData%numBlades = SrcInitInputData%numBlades
   DstInitInputData%airDens = SrcInitInputData%airDens
   DstInitInputData%kinVisc = SrcInitInputData%kinVisc
   DstInitInputData%numBladeNodes = SrcInitInputData%numBladeNodes
   if (allocated(SrcInitInputData%AFindx)) then
      LB(1:2) = lbound(SrcInitInputData%AFindx, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%AFindx, kind=B8Ki)
      if (.not. allocated(DstInitInputData%AFindx)) then
         allocate(DstInitInputData%AFindx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AFindx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%AFindx = SrcInitInputData%AFindx
   end if
   DstInitInputData%DMSTMod = SrcInitInputData%DMSTMod
   DstInitInputData%Nst = SrcInitInputData%Nst
   DstInitInputData%DMSTRes = SrcInitInputData%DMSTRes
   if (allocated(SrcInitInputData%radius)) then
      LB(1:2) = lbound(SrcInitInputData%radius, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%radius, kind=B8Ki)
      if (.not. allocated(DstInitInputData%radius)) then
         allocate(DstInitInputData%radius(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%radius.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%radius = SrcInitInputData%radius
   end if
end subroutine

subroutine DMST_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(DMST_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DMST_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitInputData%chord)) then
      deallocate(InitInputData%chord)
   end if
   if (allocated(InitInputData%AFindx)) then
      deallocate(InitInputData%AFindx)
   end if
   if (allocated(InitInputData%radius)) then
      deallocate(InitInputData%radius)
   end if
end subroutine

subroutine DMST_PackInitInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackInitInput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%chord)
   call RegPack(RF, InData%numBlades)
   call RegPack(RF, InData%airDens)
   call RegPack(RF, InData%kinVisc)
   call RegPack(RF, InData%numBladeNodes)
   call RegPackAlloc(RF, InData%AFindx)
   call RegPack(RF, InData%DMSTMod)
   call RegPack(RF, InData%Nst)
   call RegPack(RF, InData%DMSTRes)
   call RegPackAlloc(RF, InData%radius)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackInitInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackInitInput'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%chord); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numBlades); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%airDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%kinVisc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numBladeNodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AFindx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DMSTMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DMSTRes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%radius); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_InitOutputType), intent(in) :: SrcInitOutputData
   type(DMST_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyProgDesc(SrcInitOutputData%Version, DstInitOutputData%Version, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DMST_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(DMST_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DMST_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyProgDesc(InitOutputData%Version, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DMST_PackInitOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackInitOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackProgDesc(RF, InData%Version) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackInitOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackInitOutput'
   if (RF%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackProgDesc(RF, OutData%Version) ! Version 
end subroutine

subroutine DMST_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_OtherStateType), intent(in) :: SrcOtherStateData
   type(DMST_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DMST_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOtherStateData%Vstr)) then
      LB(1:3) = lbound(SrcOtherStateData%Vstr, kind=B8Ki)
      UB(1:3) = ubound(SrcOtherStateData%Vstr, kind=B8Ki)
      if (.not. allocated(DstOtherStateData%Vstr)) then
         allocate(DstOtherStateData%Vstr(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Vstr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%Vstr = SrcOtherStateData%Vstr
   end if
   if (allocated(SrcOtherStateData%M_ag)) then
      LB(1:4) = lbound(SrcOtherStateData%M_ag, kind=B8Ki)
      UB(1:4) = ubound(SrcOtherStateData%M_ag, kind=B8Ki)
      if (.not. allocated(DstOtherStateData%M_ag)) then
         allocate(DstOtherStateData%M_ag(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%M_ag.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%M_ag = SrcOtherStateData%M_ag
   end if
   if (allocated(SrcOtherStateData%blade_theta)) then
      LB(1:2) = lbound(SrcOtherStateData%blade_theta, kind=B8Ki)
      UB(1:2) = ubound(SrcOtherStateData%blade_theta, kind=B8Ki)
      if (.not. allocated(DstOtherStateData%blade_theta)) then
         allocate(DstOtherStateData%blade_theta(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%blade_theta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%blade_theta = SrcOtherStateData%blade_theta
   end if
   if (allocated(SrcOtherStateData%indf)) then
      LB(1:2) = lbound(SrcOtherStateData%indf, kind=B8Ki)
      UB(1:2) = ubound(SrcOtherStateData%indf, kind=B8Ki)
      if (.not. allocated(DstOtherStateData%indf)) then
         allocate(DstOtherStateData%indf(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%indf.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%indf = SrcOtherStateData%indf
   end if
end subroutine

subroutine DMST_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(DMST_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DMST_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OtherStateData%Vstr)) then
      deallocate(OtherStateData%Vstr)
   end if
   if (allocated(OtherStateData%M_ag)) then
      deallocate(OtherStateData%M_ag)
   end if
   if (allocated(OtherStateData%blade_theta)) then
      deallocate(OtherStateData%blade_theta)
   end if
   if (allocated(OtherStateData%indf)) then
      deallocate(OtherStateData%indf)
   end if
end subroutine

subroutine DMST_PackOtherState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackOtherState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%Vstr)
   call RegPackAlloc(RF, InData%M_ag)
   call RegPackAlloc(RF, InData%blade_theta)
   call RegPackAlloc(RF, InData%indf)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackOtherState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackOtherState'
   integer(B8Ki)   :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%Vstr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%M_ag); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%blade_theta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%indf); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_ParameterType), intent(in) :: SrcParamData
   type(DMST_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DMST_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%DT = SrcParamData%DT
   if (allocated(SrcParamData%chord)) then
      LB(1:2) = lbound(SrcParamData%chord, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%chord, kind=B8Ki)
      if (.not. allocated(DstParamData%chord)) then
         allocate(DstParamData%chord(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%chord.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%chord = SrcParamData%chord
   end if
   DstParamData%numBlades = SrcParamData%numBlades
   DstParamData%airDens = SrcParamData%airDens
   DstParamData%kinVisc = SrcParamData%kinVisc
   DstParamData%numBladeNodes = SrcParamData%numBladeNodes
   if (allocated(SrcParamData%AFindx)) then
      LB(1:2) = lbound(SrcParamData%AFindx, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%AFindx, kind=B8Ki)
      if (.not. allocated(DstParamData%AFindx)) then
         allocate(DstParamData%AFindx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFindx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%AFindx = SrcParamData%AFindx
   end if
   DstParamData%DMSTMod = SrcParamData%DMSTMod
   DstParamData%Nst = SrcParamData%Nst
   DstParamData%DMSTRes = SrcParamData%DMSTRes
   if (allocated(SrcParamData%radius)) then
      LB(1:2) = lbound(SrcParamData%radius, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%radius, kind=B8Ki)
      if (.not. allocated(DstParamData%radius)) then
         allocate(DstParamData%radius(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%radius.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%radius = SrcParamData%radius
   end if
   if (allocated(SrcParamData%dTheta)) then
      LB(1:1) = lbound(SrcParamData%dTheta, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%dTheta, kind=B8Ki)
      if (.not. allocated(DstParamData%dTheta)) then
         allocate(DstParamData%dTheta(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dTheta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%dTheta = SrcParamData%dTheta
   end if
   if (allocated(SrcParamData%theta_st)) then
      LB(1:1) = lbound(SrcParamData%theta_st, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%theta_st, kind=B8Ki)
      if (.not. allocated(DstParamData%theta_st)) then
         allocate(DstParamData%theta_st(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%theta_st.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%theta_st = SrcParamData%theta_st
   end if
   if (allocated(SrcParamData%indf)) then
      LB(1:1) = lbound(SrcParamData%indf, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%indf, kind=B8Ki)
      if (.not. allocated(DstParamData%indf)) then
         allocate(DstParamData%indf(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%indf.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%indf = SrcParamData%indf
   end if
end subroutine

subroutine DMST_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(DMST_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DMST_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%chord)) then
      deallocate(ParamData%chord)
   end if
   if (allocated(ParamData%AFindx)) then
      deallocate(ParamData%AFindx)
   end if
   if (allocated(ParamData%radius)) then
      deallocate(ParamData%radius)
   end if
   if (allocated(ParamData%dTheta)) then
      deallocate(ParamData%dTheta)
   end if
   if (allocated(ParamData%theta_st)) then
      deallocate(ParamData%theta_st)
   end if
   if (allocated(ParamData%indf)) then
      deallocate(ParamData%indf)
   end if
end subroutine

subroutine DMST_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DT)
   call RegPackAlloc(RF, InData%chord)
   call RegPack(RF, InData%numBlades)
   call RegPack(RF, InData%airDens)
   call RegPack(RF, InData%kinVisc)
   call RegPack(RF, InData%numBladeNodes)
   call RegPackAlloc(RF, InData%AFindx)
   call RegPack(RF, InData%DMSTMod)
   call RegPack(RF, InData%Nst)
   call RegPack(RF, InData%DMSTRes)
   call RegPackAlloc(RF, InData%radius)
   call RegPackAlloc(RF, InData%dTheta)
   call RegPackAlloc(RF, InData%theta_st)
   call RegPackAlloc(RF, InData%indf)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackParam'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%chord); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numBlades); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%airDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%kinVisc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numBladeNodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AFindx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DMSTMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DMSTRes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%radius); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dTheta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%theta_st); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%indf); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_InputType), intent(in) :: SrcInputData
   type(DMST_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DMST_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInputData%omega = SrcInputData%omega
   if (allocated(SrcInputData%Vinf)) then
      LB(1:3) = lbound(SrcInputData%Vinf, kind=B8Ki)
      UB(1:3) = ubound(SrcInputData%Vinf, kind=B8Ki)
      if (.not. allocated(DstInputData%Vinf)) then
         allocate(DstInputData%Vinf(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vinf.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%Vinf = SrcInputData%Vinf
   end if
   if (allocated(SrcInputData%blade_theta)) then
      LB(1:2) = lbound(SrcInputData%blade_theta, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%blade_theta, kind=B8Ki)
      if (.not. allocated(DstInputData%blade_theta)) then
         allocate(DstInputData%blade_theta(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%blade_theta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%blade_theta = SrcInputData%blade_theta
   end if
   if (allocated(SrcInputData%Vstr)) then
      LB(1:3) = lbound(SrcInputData%Vstr, kind=B8Ki)
      UB(1:3) = ubound(SrcInputData%Vstr, kind=B8Ki)
      if (.not. allocated(DstInputData%Vstr)) then
         allocate(DstInputData%Vstr(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vstr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%Vstr = SrcInputData%Vstr
   end if
   if (allocated(SrcInputData%M_ag)) then
      LB(1:4) = lbound(SrcInputData%M_ag, kind=B8Ki)
      UB(1:4) = ubound(SrcInputData%M_ag, kind=B8Ki)
      if (.not. allocated(DstInputData%M_ag)) then
         allocate(DstInputData%M_ag(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%M_ag.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%M_ag = SrcInputData%M_ag
   end if
   if (allocated(SrcInputData%PitchAndTwist)) then
      LB(1:2) = lbound(SrcInputData%PitchAndTwist, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%PitchAndTwist, kind=B8Ki)
      if (.not. allocated(DstInputData%PitchAndTwist)) then
         allocate(DstInputData%PitchAndTwist(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%PitchAndTwist.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%PitchAndTwist = SrcInputData%PitchAndTwist
   end if
   if (allocated(SrcInputData%blade_st)) then
      LB(1:2) = lbound(SrcInputData%blade_st, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%blade_st, kind=B8Ki)
      if (.not. allocated(DstInputData%blade_st)) then
         allocate(DstInputData%blade_st(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%blade_st.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%blade_st = SrcInputData%blade_st
   end if
   if (allocated(SrcInputData%UserProp)) then
      LB(1:2) = lbound(SrcInputData%UserProp, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%UserProp, kind=B8Ki)
      if (.not. allocated(DstInputData%UserProp)) then
         allocate(DstInputData%UserProp(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%UserProp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%UserProp = SrcInputData%UserProp
   end if
end subroutine

subroutine DMST_DestroyInput(InputData, ErrStat, ErrMsg)
   type(DMST_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DMST_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InputData%Vinf)) then
      deallocate(InputData%Vinf)
   end if
   if (allocated(InputData%blade_theta)) then
      deallocate(InputData%blade_theta)
   end if
   if (allocated(InputData%Vstr)) then
      deallocate(InputData%Vstr)
   end if
   if (allocated(InputData%M_ag)) then
      deallocate(InputData%M_ag)
   end if
   if (allocated(InputData%PitchAndTwist)) then
      deallocate(InputData%PitchAndTwist)
   end if
   if (allocated(InputData%blade_st)) then
      deallocate(InputData%blade_st)
   end if
   if (allocated(InputData%UserProp)) then
      deallocate(InputData%UserProp)
   end if
end subroutine

subroutine DMST_PackInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackInput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%omega)
   call RegPackAlloc(RF, InData%Vinf)
   call RegPackAlloc(RF, InData%blade_theta)
   call RegPackAlloc(RF, InData%Vstr)
   call RegPackAlloc(RF, InData%M_ag)
   call RegPackAlloc(RF, InData%PitchAndTwist)
   call RegPackAlloc(RF, InData%blade_st)
   call RegPackAlloc(RF, InData%UserProp)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackInput'
   integer(B8Ki)   :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%omega); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Vinf); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%blade_theta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Vstr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%M_ag); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PitchAndTwist); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%blade_st); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%UserProp); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(DMST_OutputType), intent(in) :: SrcOutputData
   type(DMST_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DMST_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputData%Vind)) then
      LB(1:3) = lbound(SrcOutputData%Vind, kind=B8Ki)
      UB(1:3) = ubound(SrcOutputData%Vind, kind=B8Ki)
      if (.not. allocated(DstOutputData%Vind)) then
         allocate(DstOutputData%Vind(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vind.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Vind = SrcOutputData%Vind
   end if
   if (allocated(SrcOutputData%indf)) then
      LB(1:2) = lbound(SrcOutputData%indf, kind=B8Ki)
      UB(1:2) = ubound(SrcOutputData%indf, kind=B8Ki)
      if (.not. allocated(DstOutputData%indf)) then
         allocate(DstOutputData%indf(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%indf.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%indf = SrcOutputData%indf
   end if
end subroutine

subroutine DMST_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(DMST_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DMST_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputData%Vind)) then
      deallocate(OutputData%Vind)
   end if
   if (allocated(OutputData%indf)) then
      deallocate(OutputData%indf)
   end if
end subroutine

subroutine DMST_PackOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DMST_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DMST_PackOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%Vind)
   call RegPackAlloc(RF, InData%indf)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DMST_UnPackOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DMST_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DMST_UnPackOutput'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%Vind); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%indf); if (RegCheckErr(RF, RoutineName)) return
end subroutine
END MODULE DMST_Types
!ENDOFREGISTRYGENERATEDFILE
